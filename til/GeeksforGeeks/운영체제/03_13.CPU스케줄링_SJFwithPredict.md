- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# CPU스케줄링_SJF with predicted burst time

- 최대 처리량 및 최소 평균 대기시간(WT) 및 소요 시간(TAT)을 제공하기 때문에 최적의 스케줄링 알고리즘이지만 프로세스의 버스트 시간을 예측할 수 없어서 실제로 구현할 수가 없었다.
- 다음 CPU 버스트의 길이에 대한 근사치를 계산해 가장 짧은 예측 CPU 버스트로 프로세스를 선택할 수 있다.



##### 프로세스 버스트 시간 예측 방법

1. 정적 방법

   - 프로세스 크기 : 이전에 실행했던 프로세스의 버스트 타임은 크기가 비슷한 프로세스에도 비슷한 버스트 타임일 것이다.
   - 프로세스 유형 : 운영체제 프로세스(스케줄러, 디스패처, 분할, 조각화)는 사용자 프로세스(게임, 응용 프로그램 소프트웨어) 보다 빠르다.

   ※ 이 방법들은 항상 적확하게 예측되지 않으므로 신뢰할 수 없다.



2. 동적 방법

   - t(i)를 i번째 과정의 실제 버스트 시간으로 t(n+1)을 n+1 번째 과정에 대해 예측 된 버스트 시간으로 놓는다.

     - 평균 - 주어진 n개의 프로세스 (P1 P2 ... Pn)

       - T(n+1) = 1/n(∑ 1~n까지 t(i))

     - 지수 평균(에이징)

       - T(n+1) = α t(n) + (1-α) T(n)

       여기서 α는 평활화 인자이며 0 <= α <= 1

       t(n) = N의 실제 버스트 시간(일공정)

       T(n) = N의 버스트 시간 예측 처리

   - Smoothening factor (α)

     - 우리 예측의 최근 및 과거 이력의 상대적 가중치를 제어한다.
       - α = 0 인 경우, T(n+1) = T(n) 초기 예측된 버스트 시간 값은 변하지 않는다.
       - α = 1 인 경우, T(n+1) = t(n) 즉, 새로운 프로세스의 예측된 버스트 시간은  n번째 프로세스의 실제 버스트 시간에 따라 변경된다.
       - α = 1/2 인 경우, 최근 및 과거 이력에는 똑같이 가중치가 부여된다.