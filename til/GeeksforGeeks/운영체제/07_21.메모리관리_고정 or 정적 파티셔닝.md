- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 메모리관리_고정 or 정적 파티셔닝

- 운영 체제에서 메모리 관리는 컴퓨터의 주 메모리를 할당하고 관리하는 기능이다. 메모리 관리 기능은 각 메모리 위치의 상태를 추적해 할당되었거나 자유롭게 기본 메모리를 효과적이고 효율적으로 사용하도록 한다.

#### 메모리 관리 기법

##### 연속기법 (Contiguous Technique)

- 실행 프로세스가 전체적으로 메인 메모리에 로드 되어야 한다.
  - 고정(또는 정적) 파티셔닝
  - 가변(또는 동적) 파티셔닝

###### 고정 파티셔닝

- 하나 이상의 프로세스를 메인 메모리에 넣는 데 사용되는 가장 오래되고 간단한 기술이다. 이 분할에서 RAM의 분할 수 (겹치지 않음)는 고정되어 있지만 각 분할의 영역의 크기는 같거나 다를 수 잇다. 그대로 연속해서 할당하기 때문에 어느정도 스패닝을 허용한다. 여기서 파티션은 실행 전에 또는 시스템 구성 중에 만들어 진다.

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/444-4.png)

- 그림 처럼 첫 프로세스는 주 메모리에서 4MB 중 1MB 만 소모한다. 따라서 첫 번째 블록의 내부 단편화는 4-1 = 3MB이다.

- 모든 블록에서 내부 단편화의 합 = (4-1)+(8-7)+(8-7)+(16-14) = 3+1+1+2 = 7MB

- 크기가 7MB인 프로세스 P5가 있다고 가정한다. 그러나 이 프로세스는 인접한 할당(스패닝이 허용되지 않음)으로 인해 사용 가능한 여유 공간을 감안할 때 수용 할 수 없다. 따라서 7MB는 External Fragmentation의 일부가 된다.



###### 고정 파티셔닝의 장점

- **쉬운 구현** : 내부 및 외부 단편화의 출현에 집중하지 않고 프로세스를 특정 파티션에 배치하기만 하면 된다.
- **작은 OS 오버 헤드** : 고정 파티션의 처리는 덜 과도한 간접 계산 능력을 필요로 한다.

###### 고정 파티셔닝의 단점

- 내부 단편화
  - 주 메모리 사용은 비 효율적이다. 아무리 작은 프로그램이든 전체 파티션을 차지한다. 이 때문에 내부 단편화가 발생할 수 있다.
- 외부 단편화
  - 사용 가능한 공간이 있지만 연속적인 형식이 아닌 경우(스패닝이 허용되지 않기 때문에) 다양한 파티션의 사용되지 않은 공간 (위에서 설명한 대로)을 사용해 프로세스를 로드할 수 없다.
- 프로세스 크기 제한
  - 주 메모리의 파티션 크기보다 큰 크기의 프로세스는 수용 할 수 없다. 파티션 크기는 들어오는 프로세스 크기의 크기에 따라 달라질 수 없다.
- 멀티 프로그래밍 정도에 대한 제한
  - 실행 전에 또는 시스템 구성 중에 메인 메모리의 파티션이 만들어 진다. 주 메모리는 고정된 수의 파티션으로 나뉜다. n1 RAM에 파티션 n2이 있고 프로세스 수인 경우 n2 <= n1 조건을 충족해야 한다고 가정한다. 고정 파티션에서 RAM의 파티션 수보다 많은 프로세스 수가 유효하지 않다.