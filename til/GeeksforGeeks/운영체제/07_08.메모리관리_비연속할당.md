- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 메모리관리_비연속할당

- 페이징 및 세그멘테이션은 프로세스의 물리적 주소 공간이 인접하지 못하게 하는 두 가지 방법이다. 메모리 낭비를 줄여주는 장점이 있지만 주소 변환에 의한 오버 헤드를 증가시킨다. 주소 변환에 시간이 소비되기 때문에 메모리 실행이 느려진다.
- 비 연속적 할당에서 운영체제는 메모리 공간에서 프로세스에 의해 획득된 각 블록의 기본 주소를 포함하는 각 프로세스에 대해 페이지 테이블 이라고 하는 테이블을 유지 관리해야 한다. 인접 하지 않은 메모리 할당에서 프로세스의 다른 부분은 주 메모리의 다른 위치에 할당된다. 동적 또는 정적 연속 메모리 할당과 같은 다른 기법에서는 불가능한 스패닝이 허용된다. 이것이 효과적인 메모리 할당을 보장하기 위해 페이징이 필요한 이유이다. 페이징은 외부 조각화를 제거하기 위해 수행된다.

#### 과정

- 프로세스는 비 연속적 방식으로 주 메모리의 다른 공간에 걸쳐 있을 수 있습니다. 크기가 4KB인 프로세스 P를 가정할 때, 총 여유 공간은 2*2 = 4KB 이다. 연속 메모리 할당에서 프로세스P는 스패닝이 허용되지 않으므로 조정할 수 없다.
- 연속 할당 메모리의 공간은 전체 프로세스에서 할당되어야 한다. 그렇지 않으면 그 공간은 할당되지 않은 상태로 남는다. 그러나 비 연속 할당에서는 프로세스를 여러 부분으로 나누어 주 메모리 공간을 채울 수 있다. 이 예에서 프로세스 P의 한 부분은 주 메모리의 첫 번째 2KB 공간에 할당되고 프로세스 P의 다른 부분은 주 메모리의 두 번째 2KB 공간에 할당 될 수 있다.

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/1-353.png)

- 여기서 프로세스를 어떤 방식으로 나눠 주 메모리에 할당할 것인지 이해하는 것이 중요한데 프로세스는 주 메모리에서 빈 공간의 수와 크기를 분석 한 후에 나눠진다. 이때 매우 많은 시간이 걸리는 과정을 거치는데 이들의 크기는  주메모리에 이미 존재하는 프로세스의 실행으로 매번 변경된다.
- 이런 시간 소모적인 프로세스를 피하기 위해 우리는 실행을 위해 메모리를 옮길 때 도달하기 전에 프로세스를 2차 메모리로 사전 분할한다. 모든 프로세스는 페이지라는 동일한 크기의 여러부분으로 나뉜다. 또한 메인 메모리를 Frames라는 크기의 다른 크기로 나눈다.

```c
Size of page in process 
= Size of frame in memory 
```

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/1-1-1.png)

주 메모리는 다음과 같다.

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/2222-6.png)

- 결론적으로 페이징은 프로세스의 메모리 주소 공간을 인접하지 않게 한다. 페이징은 프로세스의 페이지만 이동하므로 더 유연하다. 연속적인 메모리 할당보다 더 많은 프로세스가 주 메모리에 상주할 수 있다.