학습을 위해 글을 올립니다.

- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 메모리관리_메모리 관리의 오버레이

- 고정 파티셔닝의 주된 문제는 프로세스의 크기가 파티션의 최대 크기에 의해 제한되어야 한다는 것이다. 즉, 프로세스가 다른 파티션보다 길어질 수는 없다. 이 문제를 해결하기 위해 초기 사람들은 오버레이라고 한다.
- **오버레이**의 개념은 프로세스가 실행될 때마다 동시에 전체 프로그램을 사용하지 않고 일부만 사용한다는 것이다. 오버레이 개념은 필요한 부분이 무엇이든 간에 부품을 다 로드 했을 때 그냥 언로드한다. 그냥 다시 필요한 새로운 부분을 가져와 실행한다. 형식적으로, "프로그램 코드나 다른 데이터 블록을 내부 메모리로 옮겨서 이미 저장된 것을 대체하는 프로세스"이다. 때로는 가장 큰 파티션의 크기에 비해 프로그램의 크기가 더 커질 수 있다. 그런 경우 오버레이를 사용해야 한다.
- 따라서 오버레이는 특정 시간에 필요한 지시 사항과 데이터만 유지함으로써 실제 메모리의 크기보다 큰 프로그램을 실행하는 기술이다. 모든 모듈이 필요하지는 않은 방식으로 프로그램을 같은 시간동안 모듈에 제공한다.

##### 장점

- 메모리 요구량 줄이기
- 시간 단축

##### 단점

- 오버랩 맵은 프로그래머가 지정해야 한다.
- 프로그래머는 메모리 요구 사항을 알아야 한다.
- 겹쳐진 모듈은 완전히 분리되어야 한다.
- 오버레이 구조의 프로그래밍 설계가 복잡하고 모든 경우에 가능하지는 않는다.

##### 예시

- 오버레이의 가장 좋은 예시는 어셈블러이다. 어셈블러에 2개의 패스가 있는 경우 2 패스는 첫 번째 패스 또는 두 번째 패스 중 하나만 수행 할 수 있음을 의미한다. 첫 번째 패스를 먼저 완료한 다음 2차 통과해 사용 가능한 주 메모리 크기는 150KB이고 총 코드 크기는 200KB라고 가정한다.

```c
Pass 1.......................70KB
Pass 2.......................80KB
Symbol table.................30KB
Common routine...............20KB
```

- 전체 코드 크기가 200KB 이고 주 메모리 크기가 150KB 이기 때문에 2개의 패스를 함께 사용할 수 없다. 이 경우 오버레이 기술을 사용해야 한다. 오버레이 개념에 따라 한 번만 전달된다. 오버레이 드라이버가 10KB 라면 필요한 최소 파티션 크기는 얼마일까?
  - 패스 1에 필요한 전체 메모리 = 70+30+20+10 = 130KB
  - 패스 2에 필요한 전체 메모리 = 80+30+20+10 = 140KB 이다. 
  - 최소 140KB 크기 파티션이 있으면 코드를 쉽게 실행 할 수 있다.

##### 오버레이 드라이버

- 오버레이를 처리하는 것은 사용자의 책임이다. 운영체제는 아무것도 제공하지 않는다. 사용자가 1단계에서 필요한 부분을 작성해야 하며 1단계가 끝나면 사용자는 패스 1을 꺼내고 패스 2를 로드하는 코드를 작성한다. 오버레이 드라이버는 우리가 이동해 여러 부분으로 이동하는데 도움을 줄것이다.