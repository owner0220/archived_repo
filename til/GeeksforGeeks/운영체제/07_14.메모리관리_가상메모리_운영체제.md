- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 메모리관리_가상메모리\_운영체제

- 가상 메모리는 보조 메모리를 주 메모리의 일부로 처리 할 수 있는 저장소 할당 체계입니다. 프로그램이 메모리를 참조하는 데 사용할 수 있는 주소는 메모리 시스템이 물리적 저장 사이트를 식별하는 데 사용하는 주소와 구별되며 프로그램 생성 주소는 자동으로 해당 컴퓨터 주소로 변환된다.
- 가상 저장 장치의 크기는 컴퓨터 시스템의 주소 지정 체계에 의해 제한되며 보조 기억 장치의 양은 주 기억 장치 위치의 실제 번호가 아닌 사용 가능하다.

- 하드웨어와 소프트웨어를 사용해 구현되는 기술이다. 가상 주소라고 하는 프로그램에서 사용하는 메모리 주소를 컴퓨터 메모리의 실제 주소로 매핑한다.

1. 프로세스 내의 모든 메모리 참조는 런타임에 동적 주소로 동적으로 변환되는 논리 주소입니다. 즉, 프로세스가 실행 중에 다른 시간에 주 메모리의 다른 위치를 차지하도록 프로세스를 주 메모리로 스왑하거나 스왑 할 수 있다.
2. 프로세스는 다수의 조각으로 분할 될 수 있으며 이러한 조각은 실행 중에 주 메모리에 연속적으로 배치 될 필요는 없다. 동적 런타임 addres 변환과 페이지 또는 세그먼트 테이블 사용의 결합은 이것을 허용한다.

- 이러한 특성이 존재하면, 실행 중에 모든 페이지 또는 세그먼트가 주 메모리에 존재할 필요는 없다. 즉, 필요할 때마다 필요한 페이지를 메모리에 로드해야 한다. 가상 메모리는 수요 페이징 또는 수요 분할을 사용해 구현된다.

#### 수요 페이징 : 수요

- 수요에 따라 페이지를 메모리에 로드하는 프로세스(페이지 오류가 발생할 때마다)를 수요 페이징이라고 한다.

![virtual_mem](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/VirtualDiagram-1.png)

1. CPU가 현재 주 메모리에서 사용할 수 없는 페이지를 참조하려고하면 ㅁ모리 액세스 오류를 나타내는 인터럽트를 생성한다.
2. OS는 차단 된 프로세스를 차단 상태로 만든다. 실행을 계속하려면 OS가 필요한 페이지를 메모리로 가져와야 한다.
3. OS는 논리 주소 공간에서 필요한 페이지를 검색한다.
4. 필요한 페이지가 논리적 주소 공간에서 물리적 주소 공간으로 가져온다. 페이지 교체 알고리즘은 물리적 주소 공간에서 페이지를 교체하는 의사 결정에 사용된다.
5. 그에 따라 페이지 테이블이 업데이트 된다.
6. 프로그램 실행을 계속하기 위해 신호가 CPU로 전송되고 프로세스가 준비 상태로 되돌아 간다.

따라서 페이지 폴트가 발생할 때마다 운영 체제가 이 단계를 수행하고 필요한 페이지가 메모리로 가져온다.



##### 장점 :

- 주 메모리에 더 많은 프로세스가 유지 될 수 있다. 특정 프로세스의 일부 페이지만 로드하기 때문에 더 많은 프로세스를 위한 여지가 있다. 이는 특정 시간에 더 많은 프로세스 중 하나이 이상이 준비 상태가 될 가능성이 높으므로 프로세서를 보다 효율적으로 활용하게 한다.
- 프로세스는 모든 주 메모리보다 클 수 있다. 프로그래밍에서 가장 근본적인 제한 중 하나가 해제된다. 요구 페이징 때문에 주 메모리보다 큰 프로세스가 실행 될 수 있다. OS 자체는 필요에 따라 메인 메모리에 있는 프로세스의 페이지를 로드한다.
- 각 프로세스에 사용 가능한 (기본) 메모리를 적게 사용해 더 많은 다중 프로그래밍 수준을 제공한다.

##### 페이지 오류 서비스 시간 : 페이지 오류를 처리

- 이 처리 시간을 페이지 오류 서비스 시간이라고 한다. 페이지 오류 서비스 시간에는 위의 6단계를 모두 수행하는데 걸리는 시간이 포함된다.

```c
주 메모리 접근 시간을 m이라고합시다 : m
페이지 오류 서비스 시간 : s
페이지 오류율 : p
그런 다음, 유효 메모리 액세스 시간 = (p * s) + (1-p) * m
```

##### 교환 :

프로세스를 교환한다는 것은 메모리에서 페이지를 모두 제거하거나 보통 페이지 교체 프로세스에 의해 제거되도록 표시하는 것을 의미한다. 프로세스를 일시 중단하면 프로세스를 스왑 아웃하는 동안 실행 가능하지 않다. 나중에 시스템은 보조 스토리지에서 프로세스를 메인 메모리로 스왑한다. 프로세스가 페이지를 바꿔 넣거나 바꿔 쓰는 상황을 쓰레싱이라고 한다.

![ì¤ì](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/VirtualDiagram-2.png)

##### 쓰래씽(Thrashing)

- 주어진 시간에 프로세스의 몇 페이지만 주 메모리에 있으므로 더 많은 프로세스가 메모리에서 유지 관리 될 수 있다. 사용되지 않은 페이지가 메모리로 스왑되거나 스왑 아웃 되지 않기 때문에 시간이 절약된다. 그러나 운영 체제는 이 구성표를 관리하는 방법에 대해 영리해야 한다. 정상 상태에서 실질적으로 모든 주 메모리가 프로세스의 페이지로 채워져 프로세서와 OS가 가능한 한 많은 프로세스에 직접 액세스 할 수 있다. 따라서 OS가 한 페이지를 가져오면 다른 페이지를 버려야한다. 사용 직전에 페이지를 버리면 거의 즉시 해당 페이지를 다시 가져와야한다. 시스템은 지침을 실행하기보다는 페이지를 교체하는 데 대부분의 시간을 소비한다. 그래서 좋은 페이지 교체 알고리즘이 필요하다.

![virtual_mem_2](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/VirtualDiagram-3.png)

- 주어진 다이어그램에서, 어느 정도까지 점(lamda)까지 다중 프로그래밍의 초기 정도, CPU 사용률이 매우 높으며 시스템 리소스가 100% 활용된다. 그러나 멀티 프로그래밍의 정도를 더 높이면 CPU 사용률은 급격히 떨어지고 시스템은 페이지 교체에만 더 많은 시간을 소비하게 되고 프로세스 실행을 완료하는데 소요되는 시간이 증가한다. 시스템의 이러한 상황을 쓰래씽이라 한다.

##### 쓰래씽의 원인 : 

1. **높은 수준의 다중 프로그래밍**

- 프로세스의 수가 각 프로세스에 할당 된 프레임 수보다 메모리에서 계속 증가하면 감소한다. 따라서 각 프로세스에서 사용할 수 있는 프레임의 수는 적다. 이로 인해 페이지 폴트가 더 자주 발생하고 페이지를 스왑할 때 더 많은  CPU 시간이 낭비되고 사용률이 계속 감소한다. 예를 들면 다음과 같다.
- Free frames = 400
- **사례1** 프로세스 수 = 100 각 프로세스는 4 프레임을 얻는다.
- **사례2** 프로세스 수 = 400 각 프로세스는 1프레임을 얻는다. 사례2는 쓰래씽의 조건이며, 프로세스의 수가 증가함에 따라 프로세스 당 프레임의 수가 감소한다. 따라서 CPU 시간은 페이지 스와핑에서 소모된다.

2. **프레임 부족**

- 프로세스의 프레임 수가 적으면 해당 프로세스의 페이지 수가 적어 메모리에 상주 할 수 있으므로 더 자주 빈번히 교체가 필요하다. 이것은 쓰래씽으로 이어질 수 있다. 따라서 쓰래씽을 방지하기 위해 충분한 양의 프레임을 각 프로세스에 할당해야 한다.

##### 쓰래씽 복구 :

- 장기 스케줄러에게 임계 값 이후 프로세스를 메모리로 가져 가지 않도록 지시해 시스템이 쓰래씽을 일으키지 않도록 한다.
- 시스템이 이미 쓰래씽에 빠져있다면 중간 단계 스케줄러에 프로게스 중 일부를 중지하도록 명령해 쓰래씽으로부터 시스템을 복구 할 수 있다.



