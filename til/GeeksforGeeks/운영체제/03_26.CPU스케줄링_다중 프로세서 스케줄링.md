- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# CPU스케줄링_다중 프로세서 스케줄링

- 다중 프로세서 스케줄링에서는 다중 CPU를 사용할 수 있으므로 로드 공유가 가능해진다. 그러나 다중 프로세서 스케줄링은 단일 프로세서 스케줄링에 비해 더 복잡합니다. 다중 프로세서 스케줄링에서 프로세서가 동일한 경우 즉, HOMOGENEOUS인 경우, 기능면에서 대기열의 모든 프로세스를 실행할 수 있는 프로세서를 사용할 수 있다.



##### 다중프로세서 스케줄링 접근법

- 모든 스케줄링 결정 및 I/O 처리가 마스터 서버라고 하는 단일 프로세서에 의해 처리되고 다른 프로세서가 사용자 코드만 실행하는 경우이다. 이는 간단하고 데이터 공유의 필요성을 줄여준다. 이 것을 비대칭 다중터리라고 한다.
- 두번째 접근법은 각 프로세서가 자체 스케줄링을 하는 Symmetric Multiprocessing을 사용한다. 모든 프로세스는 공통 준비 대기열에 있거나 각 프로세서는 준비된 프로세스를 위한 자체 대기열을 가질 수 있다. 스케줄링은 각 프로세서에 대한 스케줄러가 준비 대기열을 검사하고 실행할 프로세스를 선택하도록 함으로써 진행된다.



##### 프로세서 선호도

- 프로세스가 특정 프로세서에서 실행될 때 캐시 메모리에 특정 효과가 있습니다. 프로세스에 의해 가장 최근에 액세스된 데이터는 프로세서에 대한 캐시를 채우고 결과적으로 프로세스에 의한 연속적인 메모리 액세스는 종종 캐시 메모리에서 충족됩니다. 이제 프로세스가 다른 프로세서로 마이그레이션 되면 첫 번재 프로세서에서 캐시 메모리의 내용을 무효화하고 두 번째 프로세세의 캐시를 다시 세워야 한다. 캐시를 무효화하고 다시 채우는데 드는 높은 비용 때문에 대부분의 SMP(Symmetric Multiprocessing)시스템은 한 프로세서에서 다른 프로세서로 프로세스를 마이그레이션 하는 것을 피하고 동일한 프로세서에서 프로세스를 실행하려고 합니다. 이를 프로세서 익명(PROCESSOR AFFINITY)라고 한다.



##### 프로세스 선호도

1. Soft Affinity - 운영체제가 동일한 프로세서에서 실행중인 프로세스를 유지하려고 시도하지만 이를 보장하지 않을 경우를 말한다.
2. Hard Affinity - Linux와 같은 일부 시스템은 하드 어피니티를 지원하는 일부 시스템 호출을 제공하기 때문에 프로세스가 프로세서간에 마이그레이션 할 수 있다.



##### 로드 균형 조정

- 로드 밸런싱은 SMP 시스템의 모든 프로세서에 작업로드를 고르게 분산 시키는 현상이다. 로드 밸런싱을 각 프로세서가 실행할 수 있는 자체 프로세스 큐를 가지고 있는 시스템에서만 필요합니다. 일단 프로세서가 유휴 상태가 되면 즉시 공통 실행 대기열에서 실행 가능한 프로세스를 추출하기 때문에 로드 밸런싱은 필요하지 않습니다. SMP(Symmetric Multiprocessing)에서 모든 프로세서간에 작업 부하를 균형있게 유지하여 둘 이상의 프로세서를 사용하는 이점을 완전히 활용하려면 하나 이상의 프로세서가 유휴 상태에 있는 동안 프로세서는 높은 작업 부하를 갖고 프로세서 목록을 기다린다.



##### 로드 균형 조정 방법

1. 푸시 마이그레이션 - 푸시 마이그레이션 작업은 각 프로세서의 부하를 정기적으로 확인하고 불균형을 발견하면 과부하 된 프로세서 또는 사용량이 적은 프로세서로 프로세스를 이동하여 각 프로세서에 부하를 고르게 분산시킨다.
2. Pull Migration - Pull Migration은 유휴 프로세서가 실행중인 프로세서에서 대기중인 작업을 끌어 올때 발생한다.



##### 멀티 코어 프로세서

- 멀티 코어 프로세서에서 다중 프로세서 코어는 동일한 물리적 칩에 배치된다. 각 코어는 아키텍처 상태를 유지하도록 설정된 레지스터를 가지므로 운영 체제에는 별도의 물리적 프로세서로 나타난다. 멀티 코어 프로세서를 사용하는 SMP 시스템은 각 프로세서에 자체의 물리적 칩이 있는 시스템보다 빠르고 전력 소모가 적다.
- 그러나 멀티 코어 프로세서는 스케줄링 문제를 복잡하게 만든다. 프로세서가 메모리에 액세스 할 때 데이터를 사용할 수 있을 때까지 기다리는 데 많은 시간을 소비한다. 이 상황을 MEMORY STALL 이라고 한다. 이는 캐시 메모리에 없는 데이터에 액세스 하는 캐시 분실과 같은 여러가지 이유로 발생합니다. 이 경우 프로세서는 데이터를 메모리에서 사용할 수 있을 때까지 기다리는 시간의 50%까지 사용할 수 있다. 이 문제를 해결하기 위해 최근 하드웨어 설계는 2개 이상의 하드웨어 스레드가 각 코어에 할당 된 멀티 스레드 프로세서 코어를 구현했다. 따라서 하나의 스레드가 메모리를 기다리는 동안 멈추면 코어는 다른 스레드로 전환 할 수 있다.



##### 프로세서를 멀티 스레드 하는 방법

1. Coarse-grained Multithreading - 거친 입자 멀티 스레딩에서 스레드는 메모리 스톨과 같은 긴 대기 시간 이벤트가 발생할 때까지 프로세서에서 실행됩니다. 긴 지열 이벤트로 인한 지연 때문에 프로세서는 다른 스레드로 전환하여 실행을 시작해야 합니다. 다른 스레드가 프로세서 코어에서 실행을 시작하기 전에 명령 파이프 라인을 종료해야 하므로 스레드간 전환 비용이 높습니다. 이 새로운 쓰레드가 실행을 시작하면 파이프 라인을 명령으로 채우기 시작한다.
2. Fine-Grained Multithreading - 주로 명령 주기의 경계에서 훨씬 더 세밀한 수준으로 스레드간을 전환한다. 세분화된 시스템의 아키텍처 설계에는 스레드 전환을 위한 논리가 포함되어 결과적으로 스레드 간 전환 비용이 적다.



##### 가상화 및 스레딩

다중 프로세서 단일 CPU 시스템 조차도 다중 프로세서 시스템처럼 작동합니다. 가상화를 사용하는 시스템에서 가상화는 시스템에서 실행중인 각 가상 시스템에 하나 이상의 가상 CPU를 제공 한 다음 가상 시스템간에 물리적 CPU의 사용을 예약합니다. 대부분의 가상화 환경에는 하나의 호스트 운영 체제와 많은 게스트 운영 체제가 있습니다. 호스트 운영 체제는 가상 컴퓨터를 만들고 관리하며 각 가상 컴퓨터에는 게스트 운영 체제가 설치되어 있으며 해당 세스트 내에서 실행되는 응용프로그램이 있습니다. 각 게스트 운영체제는 시간 사용이나 실제 포함하여 특정 사용 사례, 응용 프로스램 및 사용자에 할당 될 수 있습니다.

가상화는 가상 시스템 내에서 운영체제의 우수한 스케줄링 알고리즘을 망칠수 있다.