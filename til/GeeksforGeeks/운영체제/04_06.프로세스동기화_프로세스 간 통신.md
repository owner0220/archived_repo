- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 프로세스 동기화_프로세스 간 통신

### 프로세스 유형

- 독립 프로세스
- 협력 과정

독립적인 프로세스는 다른 프로세스의 실행에 영향을 받지 않지만 협력 프로세스는 다른 실행 프로세스의 영향을 받을 수 있다. 독자적으로 운영되는 프로세스가 매우 효율적으로 실행되지만 실제로는 협업적 성격이 컴퓨터 속도, 편의성 및 모듈성을 높이는 데 활용 될 수 있는 많은 상황이 있다. 프로세스 간 통신(IPC)은 프로세스가 서로 통신하고 해당 작업을 동기화 할 수 있게 해주는 메커니즘이다. 



### 프로세스 통신 방법

1. 공유 메모리
2. 메시지 전달

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/1-76.png)

#### 통신 및 메시지 전달의 공유 메모리 방법

- 공유 메모리를 사용하는 프로세스 간의 통신은 프로세스가 일부 변수를 공유해야 하며 프로그래머가 이를 구현하는 방법에 따라 다르다. 공유 메모리를 사용하는 통신의 한 가지 방법을 다음과 같이 상상할 수 있다. process1과 process2가 동시에 실행 중이며 일부 리소스를 공유하거나 다른 프로세스의 일부 정보를 사용한다고 가정하면 process1은 사용되는 특정 계산 또는 리소스에 대한 정보를 생성하고 이를 레코드로 유지합니다. 공유 메모리 process2가 공유 정보를 사용해야 할 때, 공유 메모리에 저장된 레코드를 체크인 하고 process1에 의해 생성된 정보를 기록한 다음 그에 따라 작동한다.

##### 예 : 생산자 - 소비자 문제

- 생산자와 소비자의 두가지 프로세스가 있다. 생산자가 일부 품목을 생산하고 소비자가 해당 품목을 소비한다. 두 프로세스는 Producer에서 생성된 항목이 저장되는 버퍼와 필요한 경우 Customer가 항목을 소비하는 곳에서 공통 공간 또는 메모리 위치를 공유한다.
  1. 첫 번째는 Producer가 항목을 생성 할 수 있고 버퍼 크기에 제한이 없는 무제한 버퍼 문제
     - 생산자와 소비자는 공통적인 기억을 공유하고 생산자는 아이템을 생산하기 시작해 총 생성된 항목이 버퍼 크기와 같은 경우, 생산자는 소비자가 소비하기를 기다린다.
  2. 생산자가 생산할 수 있는 바운드 버퍼 문제 : 일정량의 품목을 소비 한 후 소비자가 소비하기를 기다리기 시작
     - 마찬가지로 소비자는 먼저 해당 항목의 가용성을 확인하고 항목이 없는 경우 소비자는 생산자가 생산할 때까지 기다린다. 사용할 수 잇는 항목이 있으면 소비자가 소비한다.

#### 통신 및 메시지 전달의 메시징 통과 방법

- 두 프로세스 p1과 p2가 서로 통신하기 위해 다음과 같이 진행한다.

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/2-50.png)

- 통신 링크를 설정한다.(링크가 있는 경우 다시 설정할 필요는 없다.)
- 기본 우선순위를 사용해 메시지 교환을 시작한다. (최소 두 개 이상의 프리미티브 필요)
  - send(메시지, 대상) 또는 send(메시지)
  - receive(메시지,host) 또는 receive(메시지)
- 메시지 크기는 고정 크기이거나 가변 크기 일 수 있다. 고정된 크기라면 OS설계자에게는 쉽지만 프로그래머에게는 복잡하고 가변적인 경우에는 프로그래머에게는 쉽지만 OS설계자에게는 복잡하다. 표준 메시지는 머리글과 본문의 두 부분으로 구성 될 수 있다. 헤더부분은 저장 메시지 유형, 대상 ID, 소스 ID, 메시지 길이에 사용 제어 정보가 된다. 제어 정보에는 버퍼 공간이 부족한 경우 수행 할 작업, 시퀀스 번호, 우선 순위와 같은 정보가 들어 있다. 일반적으로 메시지는 FIFO 를 사용해 전송된다.

#### 커뮤니케이션 링크를 통해 전달되는 메시지

##### 직접 및 간접 통신 링크

- 링크를 구현하면서 염두할 것들
  1. 링크는 어떻게 구성되어 있나?
  2. 링크를 두개 이상의 프로세스와 연결할 수 있나?
  3. 통신 프로세스의 모든 쌍 사이에 몇 개의 링크가 있을 수 있나?
  4. 링크의 용량은 얼마인가? 링크가 고정 또는 가변을 수용 할 수 있는 메시지 크기인가?
  5. 단방향 또는 양방향 링크인가?

- **직접 통신 링크**는 프로세스가 통신에 대해 특정 프로세스 식별자를 사용할 때 구현되지만 미리 송신자를 식별하기는 어렵다.



#### 메시지 교환을 통한 메시지 전달

##### 동기식 및 비동기식 메시지 전달

- 차단되는 프로세스는 리소스가 사용 가능하게 되거나 I/O 작업이 완료되는 것과 같은 일부 이벤트를 기다리는 프로세스이다. IPC는 동일한 컴퓨터의 프로세스 뿐만 아니라 다른 컴퓨터에서 실행되는 프로세스, 즉 네트워크 / 분산 시스템에서도 가능하다. 두 경우 모두 메시지를 보내거나 받는 동안 프로세스가 차단되거나 차단되지 않아서 메시지 전달이 차단되거나 차단되지 않을 수 있다. 블로킹은 **동기식**으로 간주되며 **블로킹보내기**는 수신자가 메시지를 수신할 때까지 보낸 사람이 차단됨을 의미한다. 마찬가지로 수신 차단은 메시지를 사용할 수 있을 때까지 수신자 블록을 가진다.
- **비동기** 및 비 차단 전송은 보낸 사람이 메시지를 보내고 계속한다. 마찬가지로 비 차단 수신은 수신자에게 유효한 메시지 또는 null을 수신한다. 메시지를 다른 사람에게 전달해야 할 필요가 있기 때문에 발신자에게는 메시지가 전달 된 후 차단이 되지 않는 것이 더 자연스럽다고 결론을 내릴수 있다. 
  - 차단 보내기 및 차단 수신
  - 비 차단 송신 및 비 차단 수신
  - 비 블로킹 보내기 및 수신 거부(주로 사용됨)
- **직접 메시지 전달**에서 통신하려는 프로세스는 수신자 또는 통신 발신자의 이름을 명시적으로 지정해야 한다. 
- **간접 메시지 전달** 프로세스는 메시지를 보내고 받기 위해 사서함(포트)을 사용한다. 각 사서함에는 고유한 ID가 있으며 프로세스는 사서함을 공유하는 경우에만 통신 할 수 있다. 프로세스가 공통 사서함을 공유하고 단일 링크를 여러 프로세스와 연결할 수 있는 경우에만 링크가 설정된다. 각 프로세스 쌍은 여러 통신 링크를 공유할 수 있으며 이러한 링크는 단방향 또는 양방향 일 수 있다.

