- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 알고리즘분석_루프 분석

- O(1) : 루프(loop), 재귀(recursion) 및 다른 일정하지 않은 시간 함수에 대한 호출을 포함하지 않으면 함수(또는 명령문 집합)의 시간 복잡도는 O(1)로 간주된다.

  상수만큼 돌아가는 루프는 O(1) 이다.

```c
 // 여기서 c는 상수   
   for (int i = 1; i <= c; i ++) {  
        // 일부 O (1) 표현식
   }
```



- O(n) : 루프 변수가 일정한 양만큼 증가 / 감소 되는 경우 루프의 시간 복잡도는 O(n)으로 간주한다.

```c
   // 여기서 c는 양의 정수입니다.   
   for (int i = 1; i <= n; i + = c) {  
        // 일부 O (1) 표현식
   }

   for (int i = n; i> 0; i - = c) {
        // 일부 O (1) 표현식
   }
```



- O(n^c) : 중첩 된 루프의 시간 복잡도는 가장 안쪽의 명령문이 실행된 횟수와 같다. 예를 들어 다음은 O(n^c) 시간 복잡도를 갖는다.

```c
 for (int i = 1; i <= n; i + = c) {
       for (int j = 1; j <= n; j + = c) {
          // 일부 O (1) 표현식
       }
   }

   for (int i = n; i> 0; i - = c) {
       for (int j = i + 1; j <= n; j + = c) {
          // 일부 O (1) 표현식
   }
```



- O(Logn) : 루프 변수가 일정량으로 나뉘거나 곱해진 경우 루프 복잡도는 O(Logn)으로 간주한다.

```c
   for (int i = 1; i <= n; i * = c) {
       // 일부 O (1) 표현식
   }
   for (int i = n; i> 0; i / = c) {
       // 일부 O (1) 표현식
   }
```



- O(LogLogn) 루프 변수가 일정한 양만큼 지수 함수적으로 감소 / 증가 하는 경우 루프의 복잡도는 O(LogLogn)이다.

```c
   // 여기서 c는 1보다 큰 상수입니다.   
   for (int i = 2; i <= n; i = pow (i, c)) { 
       // 일부 O (1) 표현식
   }
   // 여기 fun은 sqrt 또는 cuberoot 또는 다른 상수 루트입니다.
   for (int i = n; i> 0; i = fun (i)) { 
       // 일부 O (1) 표현식
   }
```



시간 복잡도는 최악의 경우를 고려해야 한다.

##### 재귀 함수의 시간복잡도를 계산 하는 방법

- 하나의 일을 하는 것을 함수로 생각해서 하면 된다.

- 예시) 피보나치

  f(n) = f(n-1)+f(n-2)