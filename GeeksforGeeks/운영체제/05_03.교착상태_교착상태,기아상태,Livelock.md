- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 교착상태_교착 상태, 기아 상태, Livelock

- Livelock은 둘 이상의 프로세스가 유용한 작업을 수행하지 않고 다른 프로세스의 변경에 대한 응답으로 동일한 상호작용을 계속 반복 할 때 발생한다. 이 프로세스는 대기 중 상태가 아니며 동시에 실행 중이다. 교착 상태가 발생하면 모든 프로세스가 대기 상태에 있기 때문에 교착 상태와 다르다.

![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/aaa-1.png)

```c
void process_A(void) 
{ 
    enter_reg(& resource_1); 
    enter_reg(& resource_2); 
    use_both_resources(); 
    leave_reg(& resource_2); 
    leave_reg(& resource_1); 
} 
void process_B(void) 
{ 
    enter_reg(& resource_1); 
    enter_reg(& resource_2); 
    use_both_resources(); 
    leave_reg(& resource_2); 
    leave_reg(& resource_1); 
} 
```

- 두 개의 자원을 사용하는 한 쌍의 프로세스를 상상해보자. 두 프로세스는 각각 두개의 리소스가 필요하며 폴링 프리미티브 enter_reg를 사용해 필요한 리소스를 획득하려고 시도한다. 시도가 실해 할 경우 프로세스는 다시 시도한다.
- 프로세스 A가 먼저 실행되고 리소스 1을 얻은 다음 프로세스B가 실행되고 다음에 실행되는 리소스2를 얻는 경우 리소스 2를 가져오면 더이상 진행되지 않지만 두 프로세스 모두 차단되지 않는다. 실제로 일어나는 일은 진행과정없이 CPU 퀀텀을 반복적으로 사용하지만 블로킹 없이도 사용할 수 있다. 따라서 이 상황은 교착 상태가 아니라(프로세스가 차단되지 않으므로) 교착 상태와 기능적으로 동일한 것이 있다.

##### Livelocks으로 가는 형태는?

- 일부 시스템에서 허용되는 프로세스의 총 수는 프로세스 테이블의 항목 수에 의해 결정된다. 따라서 프로세스 테이블 슬롯은 유한 리소스라고 할 수 있는데 테이블이 꽉 차서 포크가 실패하면 임의의 시간을 대기하고 다시 시도하면 포크를 수행하는 프로그램에 대한 합리적인 접근 방법이 된다.
- 프로세스 슬롯이 100개인 유닉스 시스템을 생각해 보자 10개의 프로그램이 실행 중이며, 각 프로그램은 12개 (하위)프로세스를 생성해야 한다. 각 프로세스가 9개의 프로세스를 생성한 후 10개의 원래 프로세스와 90개의 새로운 프로세스가 테이블을 소모했다. 10개의 원래 프로세스 각각은 이제 끝이 없는 루프 포킹과 실패로 자리 잡고 있다. 이는 교착상태의 상황으로 이런 일이 발생할 확률은 적지만 가능한 이야기다.