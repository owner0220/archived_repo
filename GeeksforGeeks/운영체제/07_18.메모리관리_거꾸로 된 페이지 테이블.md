- 학습을 위해 글을 올립니다.
- 모든 출처와 저작권은 Geeksforgeeks에 있습니다.

[^출처]: https://www.geeksforgeeks.org/



# 메모리관리_거꾸로 된 페이지 테이블

- 대부분의 운영 체제는 각 프로세스에 대해 별도의 페이지 표를 구현한다. 즉, 다중 처리 / 시분할 운영 체제에서 실행되는 'n'개의 프로세스에 대해 'n'개의 페이지 표가 기억한다. 경우에 따라 프로세스의 크기가 매우 크고 프로세스 크기에 따라 가상 메모리를 차지하는 경우 페이지 테이블 크기도 크게 증가한다.

```c\
예 : 크기가 2GB 인 프로세스 :
페이지 크기 = 512 바이트
페이지 테이블 엔트리의 사이즈 = 4 바이트
프로세스의 페이지 수 = 2GB / 512 B = 2 22 페이지 
테이블 크기 = 2 22 * 2 2 = 2 24 바이트
```

- 이 예를 통해 OS에서 동시에 실행되는 여러 프로세스의 경우 메모리의 상당 부분이 페이지 테이블에 의해서만 점유된다는 결론을 얻을 수 있다. 운영 체제는 또한 페이지 테이블을 저장하기 위한 공간 요구 사항을 추가로 증가 시키는 다단계 페이징 체계를 통합하고 많은 야으이 메모리가 페이지 테이블을 저장하는데 투자된다. 페이지 테이블이 차지하는 메모리의 양은 오버 헤드로 판명 될 수 있으며 주 메모리가 항상 부족한 자원이므로 항상 수용할 수 없다. 효율적으로 메모리를 활용하고 다중 프로그래밍 및 효율적인 CPU 활용 수준에서 균형을 유지하기 위해 다양한 노력이 이뤄진다.

##### Inverted Page Table

- 대체 방법은 주 메모리의 모든 프레임에 대해 하나의 페이지 테이블 항목으로 구성된 Inverted Page Table 구조를 사용하는 것이다. 따라서 역 페이지 테이블의 페이지 항목 수는 실제 메모리의 프레임 수로 줄어들고 단일 페이지 테이블은 모든 프로세스의 페이징 정보를 나타내는 데 사용된다.

- 거꾸로 된 페이지 테이블을 통해 모든 프로세스에 대한 개별 페이지 테이블을 저장하는 오버 헤드가 제거되고 모든 프로세스의 페이징 정보를 함께 저장하기 위해 고정 된 부분의 메모리만 필요하다. 논리적 페이지 번호 대신 프레임 번호를 기준으로 인덱싱을 수행하므로 이 기술은 거꾸로 된 페이징이라고 한다. 페이지 테이블의 각 항목에는 다음 필드가 들어 있다.
  - **페이지 번호** : 논리 주소의 페이지 번호 범위를 지정한다.
  - **프로세스 ID** : 거꾸로 된 페이지 테이블은 실행중인 모든 프로세스의 주소 공간 정보를 포함한다. 두 개의 서로 다른 프로세스가 비슷한 가상 주소 세트를 가질 수 있기 때문에 Inverted Page Table에서 각 프로세스의 프로세스 ID를 저장해 주소 공간을 고유하게 실별해야 한다. 이것은 Pid와 페이지 번호의 조합을 사용해 수행하게 된다. 따라서 이 프로세스 ID는 주소 공간 식별자 역할을 하며 특정 프로세스의 가상 페이지가 해당 물리적 프레임에 올바르게 매핑되도록 한다.
  - **제어 비트** : 이 비트는 여분의 페이징 관련 정보를 저장하는 데 사용된다. 여기에는 유효 비트, 더티 비트, 참조 비트, 보호 및 잠금 정보 비트가 포함된다.
  - **연결 포인터** : 두개 이상의 프로세스가 주 메모리의 일부를 공유하는 경우가 있을 수 있다. 이 경우 두 개 이상의 논리적 페이지가 동일한 페이지 테이블 항목에 매핑되면 체인 포인터가 이러한 논리적 페이지의 세부 정보를 루트 페이지 테이블에 매핑하는 데 사용된다.

  ![img](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/33-6.png)

- CPU에 의해 생성 된 가상 주소에는 필드 각 페이지 테이블 엔트리에는 페이지 관련 메커니즘에 필요한 기타 관련 정보를 제공한다. 메모리 참조가 발생하면 가상 주소는 메모리 매핑 단위와 일치하고 Inverted Pagetable은 대응하는 프레임 번호가 얻어진다. 일치하는 i번째 항목을 발견하면 프로세스 실제주소로 보내고 일치 하지 않을 경우에는 Segmentation Fault가 생성된다.

##### 장점과 단점

- **메모리 공간 감소** : 반전 된 페이지 테이블은 일반적으로 페이지 테이블을 물리적 메모리의 크기 제한에 저장하는 데 필요한 메모리 양을 줄인다. 최대 항목 수는 실제 메모리의 페이지 프레임 수 이다.
- **더 긴 조회 시간** : 프레임 번호 순서로 반전 된 페이지 표가 정렬되지만 가상 주소와 관련해 메모리 조회가 수행되므로 일반적으로 적절한 항목을 찾는 데 시간이 오래 걸리지만 종종 이러한 페이지 표는 해시 데이터를 사용해 구현됩니다. 빠른 검색을 위한 구조이다.
- **공유 메모리 구현이 어렵다** : 반전 된 페이지 테이블이 각 프레임에 대해 단일 항목을 저장하기 때문에 페이지 테이블에 공유 메모리를 구현하기가 어려워진다. 체이닝 기술은 하나 이상의 가상 주소를 프레임 번호 순서로 지정된 항목에 매핑하는데 사용된다.

